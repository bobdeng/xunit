# 创建一个测试类
作为一个负责任的程序员，我希望我写的代码，都能被程序自动化测试。因此，我需要一个工具，把我的测试方法包装起来，这样在未来我就可以通过运行这些测试方法来验证代码的正确性。
每个测试方法应该是一个void的、无入参的方法。一个测试类应该可以包括有多个测试方法，由于测试类也可能有一些非测试方法（我们假设我们也没有反射这种东西），因此需要测试类把自己的测试方法注册进来。调用者可以通过测试类，获取测试类测试方法的数量、名称。

# 运行一个测试类
我们现在已经拥有了一个测试类，并且获得了测试方法的数量、名称。接下来我们要运行这个测试类。
通过遍历测试类下的所有测试方法，并逐个运行测试方法，我们可以知道哪些方法成功了，哪些失败了。运行完毕后，我们可以得到测试类下的测试结果，包括：方法名、是否成功、失败信息（如果不成功）

# 将一组测试类做成一个套件
随着我们系统越来越复杂，我们写了越来越多的测试类，我们现在需要把一些测试类放到一起运行，称为一个套件（Suite）。运行一个测试套件，就等于运行了套件下的所有测试类。这样我们就可以获得一个测试套件的所有测试结果。除了测试类上的测试结果外，对测试套件，结果还要增加 类名，以方便我们分类显示。

# Setup和Teardown
在测试之前，我们需要准备一些数据，设定当前程序的状态，以便符合测试方法对环境的要求。有些Setup改变了系统的状态，需要在结束之后调用TearDown方法消除状态。要求在每个测试方法开始之前，运行setup，在测试方法运行只有，运行tearDown。每一个TestCase都有自己的一个setup方法和tearDown方法。

# 重新发现Annotation
一个好消息，时间来到了20XX年，Java支持了注解。我们不想再强制每个测试类都从TestCase继承，也不想手工再一个个注入测试方法、Setup、TearDown方法。我们可以通过注解，让一个普通都POJO变成测试类，并运行之。
通过@Test @Setup  @TearDown 标记测试、Setup、TearDown方法，构造并运行一个测试类。当然。由于之前功能我们都分发出去了，已经有不少人在用，所以之前完成的也必须都要兼容。
